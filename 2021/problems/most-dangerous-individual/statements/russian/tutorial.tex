\begin{tutorial}{Самый опасный индивид}

Для начала заметим, что эта задача сводится к нахождению вершины $i$ дерева, которая имеет наименьшее значение величины $ \sum_j l(i,j) $ (определим $l(i,i)=0$). Так и назовем эту величину: $ value_i = \sum_j l(i,j) $.

Чтобы найти значение value хотя бы для одной вершины необходимо найти ближайшее расстояние до каждой вершины дерева. Значит, надо обойти все вершины. Ограничение в $n\leq 600 000$ четко намекает, что мы должны решить задачу за линейное время $O(n)$. Значит, мы должны постараться сделать как можно больше за каждый обход дерева.

За один полный обход дерева мы можем собрать всю необходимую информацию о структуре дерева. В данной задаче такой информацией является значение $value$ в какой-нибудь вершине и количество потомков у каждой вершины (сначала надо принять какую-нибудь вершину за корень дерева). Примем нулевую вершину за корень дерева и начнем рекурсивный обход в ней:

\begin{verbatim}
def rec_1(i, i0, desc):
    val = 0
    desc_t = 0
    for j in adj[i]:
        if j != i0:
            val += rec_1(j, i, desc) + desc[j]
            desc_t += desc[j]

    desc[i] = desc_t+1
    return val  
\end{verbatim}

$rec_1 (i, i_0, desc) $ равен $value_i$, если предположить что поддерево, растущее от вершины $i$ является всем деревом (т.е. забыть о всех других вершиных). В итоге, мы знаем настоящее значение $value_i$ только в вершине 0. В массиве desc[i] мы вычисляем и храним кол-во потомков у каждой встреченной вершины. 

Далее, запускаем еще один рекурсивный обход в вершине 0:

\begin{verbatim}
def rec_2(i, i_0, val_0):
    if i == 0:
        val = val_0
    else:
        val = val_0 + n - desc[i]*2

    min, min_i = val, i

    for j in adj[i]:
        if j != i_0:
            t_min, t_min_i = rec_2(j, i, val)
            if t_min < min:
                min, min_i = t_min, t_min_i

    return min, min_i 
\end{verbatim}

Заметьте, что нет нужды выделять массив для хранения настоящих значений $value_i$ -- достаточно знать только о $value$ текущей вершины и минимальном значении $value$ среди уже посещенных (второй раз) вершин. $value$ текущей вершины можно вычислить по простой рекуррентной формуле, зная $value$ родительской вершины $i_0$ и кол-во потомков в вершине $i$:

$$ value_i = value_{i_0} - desc_i + (n - desc_i) $$

Чтобы понять формулу, посмотрите как меняется $value$ при переходе с $i_0$ на $i$. 

По завершению второй рекурсии, мы знаем какая вершина имеет наименьший $value$:

\begin{verbatim}
val = rec_1(0, 0, desc)  
min_i = rec_2(0, 0, val)[1]  
print(min_i)
\end{verbatim}



Важное примечание: Если написать данный алгоритм на C++, то он работает \textbf{на порядок} быстрее. Ограничения и тесты в этой задаче были подогнаны под то, чтобы Python мог уложиться по времени. Если делать на C++, то можно легко сделать до $n ~ 5 000 000 $ за данное ограничение по времени.      
 



\end{tutorial}
