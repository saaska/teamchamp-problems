\begin{tutorial}{Космический бой}

Для решения данной задачи можно использовать рекурсивный поиск в~ширину или поиск в~глубину. Однако ограничения на входные данные подразумевают большую глубину вложенности, что может привести к~нехватке памяти в~стеке. Чтобы этого избежать можно воспользоваться итеративным вариантом алгоритма поиска в~ширину.

После чтения входных данных, организуем внешний цикл по клетками. Текущую клетку помещаем в~очередь и начинаем вложенный цикл, который будет работать пока в очереди есть необработанные клетки.

Внутри вложенного цикла найдем соседние клетки данного корабля и добавим их в очередь. Затем отмечаем клетку как обработанную и переходим к следующей клетке в очереди. Как только очередь опустеет необходимо выйти из вложенного цикла и увеличить счётчик кораблей.

Важно помнить, что внешний цикл должен пропускать клетки, которые уже были обработаны во вложенном цикле.

Для большей ясности приведем пример решения на языке Python:

\begin{verbatim}
cells = {}
n = int(input())
for _ in range(n)
    i, j, k = input().split()
    cells[int(i), int(j), int(k)] = 0

number = 0
for cell, mark in cells.items():
    if mark == 0:
        number += 1
        queue = [cell]
        while queue:
            i, j, k = queue.pop(0)
            cells[i, j, k] = number
            deltas = [
                (0, 0, 1), (0, 0, -1),
                (0, 1, 0), (0, -1, 0),
                (1, 0, 0), (-1, 0, 0),
            ]
            for di, dj, dk in deltas:
                if cells.get((i + di, j + dj, k + dk)) == 0:
                    queue.append((i + di, j + dj, k + dk))

print(number)
\end{verbatim}


\end{tutorial}
