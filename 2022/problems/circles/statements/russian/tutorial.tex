\begin{tutorial}{Защита лилипутов}

Попробуем оценить для каждого круга степень его вхождения в другие. Отсортируем круги по невозрастанию радиуса. Пусть для первых $k$ кругов уже знаем степень вложенности. Тогда степень вложенности $(k+1)$-го круга~--- на один больше, чем максимальное значение степени вложенности среди первых $k$ кругов, внутри которого находится $(k+1)$-й круг. Ответ предыдущих не будет модифицироваться, так как круги отсортированы по невозрастанию радиуса. База очевидна~--- самые большие круги имеют степень вложенности $0$. Асимптотика алгоритма~--- $\mathcal{O}(N^2)$.
\newline
\\
\textbf{Псевдокод}:
\begin{verbatim}
     1  vector<Walls> walls;
     2  int dp[10005]= {0,..., 0};
     3  in >> walls;
     4  sort(walls, compareByRadius);
     5  for(int i = 0; i < wallsCount; ++i) {
     6      for(int j = 0; j < i; ++j) {
     7          if(walls[i].isContainedIn(walls[j])) {
     8              dp[i] = max(dp[i], dp[j] + 1);
     9             }
     10         }
     11     }
     12 out << getIndex(max(dp));
\end{verbatim}


\end{tutorial}
